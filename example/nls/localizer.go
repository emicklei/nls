// Code generated by github.com/emicklei/cmd/nls. DO NOT EDIT.

package nls

import (
	"fmt"
	"strings"
	"text/template"
)

const (
	M_cats = "cats"
	M_hello = "hello"
	M_multi = "multi"
	M_sea = "sea"
	M_sky = "sky"
	M_world = "world"
)

// all messages found in all language folders
var messages = map[string]string{
	"en." + M_cats: `{{.count}} {{- if gt .count 1}} cats{{- else}} cat{{- end}}`,
	"en." + M_hello: `hello`,
	"en." + M_multi: `{{.name}} says hello
to the world
`,
	"en." + M_sea: `{{.color }} sea`,
	"en." + M_sky: `sky`,
	"en." + M_world: `world`,
	"nl." + M_world: `wereld`,
	"nl." + M_cats: `{{.count}} {{- if gt .count 1}} katten{{- else}} kat{{- end}}`,
	"nl." + M_hello: `hallo`,
	"nl." + M_multi: `{{.name}} zegt hallo
tegen de wereld
`,
	"nl." + M_sea: `{{.name }} zee`,
	"nl." + M_sky: `hemel`,
}

type Params map[string]any

type Localizer struct {
	languages []string
}

// New returns a Localizer with zero or more languages.
func New(languages ...string) Localizer {
	return Localizer{languages: languages}
}

// Get returns the text associated with a key for using the available languages
// It returns an empty string if none of the languages have a (non-empty) value for the key and no fallback is provided.
func (l Localizer) Get(key string, fallback ...string) string {
	for _, lang := range l.languages {
		mapkey := fmt.Sprintf("%s.%s", lang, key)
		if v, ok := messages[mapkey]; ok && len(v) > 0 {
			return v
		}
	}
	if len(fallback) > 0 {
		return fallback[0]
	}
	return ""
}

// Format returns the text after applying substitutions using the key(string) and value pairs.
// Returns an empty string if there no such key.
func (l Localizer) Format(key string, kv ...any) string {
	params := map[string]any{}
	for i:=0;i<len(kv);i+=2{
		k := kv[i]
		if ks, ok := k.(string) ; ok{
			params[ks]=kv[i+1]
		} else {
			return "bad arguments: Format expects [string,any] pairs"
		}
	}
	return l.Replaced(key, params)
}

// Replaced returns the text after applying substitutions using the replacements.
// Returns an empty string if there no such key.
func (l Localizer) Replaced(key string, replacements ...map[string]any) string {		
	tmpl := l.Get(key)
	// If no replacements are provided, return the template as is.
	if len(replacements) == 0 {
		return tmpl
	}
	// If the tmpl doesn't have any substitutions, no need to template.Execute.
	if !strings.Contains(tmpl, "}}") {
		return tmpl
	}
	replacer, err := template.New("replacer").Parse(tmpl)
	if err != nil {
		return err.Error()
	}
	buf := new(strings.Builder)
	if err := replacer.Execute(buf, replacements[0]); err != nil {
		return err.Error()
	}
	return buf.String()
}